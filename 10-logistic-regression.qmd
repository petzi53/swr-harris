# Binary Logistic regression {#sec-chap10}

```{r}
#| label: setup
#| include: false

options(warn = 0) # default value: change for debugging. See: ?warning

base::source(file = "R/helper.R")
ggplot2::theme_set(ggplot2::theme_bw()) 
```

## Achievements to unlock

::: {#obj-chap10}
::: my-objectives
::: my-objectives-header
Objectives for chapter 10
:::

::: my-objectives-container
**SwR Achievements**

-   **Achievement 1**: Using exploratory data analysis before developing
    a logistic regression models (@sec-chap10-achievement1)
-   **Achievement 2**: Understanding the binary logistic regression
    statistical model (@sec-chap10-achievement2)
-   **Achievement 3**: Estimating a simple logistic regression model and
    interpreting predictor significance and interpretation (@sec-chap10-achievement3)
-   **Achievement 4**: Computing and interpreting two measures of model
    fit (@sec-chap10-achievement4)
-   **Achievement 5**: Estimating a larger logistic regression model
    with categorical and continuous predictors (@sec-chap10-achievement5)
-   **Achievement 6**: Interpreting the results of a larger logistic
    regression model (@sec-chap10-achievement6)
-   **Achievement 7**: Checking logistic regression assumptions and
    using diagnostics to identify outliers and influential values (@sec-chap10-achievement7)
-   **Achievement 8**: Using the model to predict probabilities for
    observations that are outside the data set (@sec-chap10-achievement8)
-   **Achievement 9**: Adding and interpreting interaction terms in
    logistic regression (@sec-chap10-achievement9)
-   **Achievement 10**: Using the likelihood ratio test to compare two
    nested logistic regression models (@sec-chap10-achievement10)
:::
:::

Achievements for chapter 10
:::

## The perplexing libraries problem

Harris defines `r glossary("digital divide")` broader and includes both limited access
to information and communication technologies (ICT) and a deficit in the
ability to use information gained through access to
ICTs[^10-logistic-regression-1]. 

[^10-logistic-regression-1]: My current research indicates that mostly
    only the first problem (limited access) falls under the definition
    ([@wikipedia2024; @oecd2001].

People were more likely to fall into this digital divide if they were poor, a racial minority, had limited education, had a disability, or lived in an area with low population density. The digital divide often exacerbated other problems like finding an employment either by not searching relevant offers using the internet or not getting the job because of missing ICT skills.

The question this chapter tries to answer: "Which characteristics are associated with library use?"




## Resources & Chapter Outline

### Data, codebook, and R packages {#sec-chap10-data-codebook-packages}

::: my-resource
::: my-resource-header
Data, codebook, and R packages for learning about descriptive statistics
:::

::: my-resource-container
**Data**

Two options for accessing the data:

1. Download the cleaned data set `pew_libraries_2016_cleaned_ch10.csv` from <https://edge.sagepub.com/harris1e>. 
2. Follow the instructions in Box 10.1 to import and clean `pew_libraries_2016_ch10.csv` from <https://edge.sagepub.com/harris1e> or download from the original Internet data source and clean.

I am using the first option because there is nothing new for me to import and clean data files.

**Codebook**

Two options:

1. Download the `pew_libraries_2016_codebook_ch10.docx` codebook file from <https://edge.sagepub.com/harris1e>.
2. Use the version that comes with the raw data file from Pew Research Center (https://www.pewinternet.org/dataset/march2016-libraries/)

**Packages**

1.  Packages used with the book (sorted alphabetically)

-   {**car**}: @pak-car (John Fox)
-   {**lmtest**}: @pak-lmtest (Achim Zeileis) 
-   {**odds.n.ends**}: @pak-odds.n.ends (Jenine Harris) 
-   {**tableone**}: @pak-tableone (Kazuki Yoshida) 
-   {**tidyverse**}: @pak-tidyverse (Hadley Wickham)

2.  My additional packages (sorted alphabetically)

-   {**skimr**}: @pak-skimr (Elin Waring)

:::
:::

## Achievement 1: EDA {#sec-chap10-achievement1}

### Get, show, and recode data

:::::{.my-example}
:::{.my-example-header}
:::::: {#exm-chap09-eda}
: EDA: Get, show and recode data
::::::
:::
::::{.my-example-container}

::: {.panel-tabset}

###### Get data

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-get-data}
: Import data from .csv file
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-get-data}
```{r}
#| label: get-data
#| eval: false

## run only once (manually)
tbl10 <- readr::read_csv(
    "data/chap10/pew_libraries_2016_cleaned_ch10.csv",
    col_types = "nffffffff"
)

save_data_file("chap10", tbl10, "tbl10.rds")

```
Get data for chapter 10
:::

(*For this R code chunk is no output available*)

***

In my first import trial it turned out that all the factor variables are imported as character variables. So I had to add the columns specifications `col_types = "nffffffff"`.

::::
:::::


###### Show data

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-show-data}
: Show raw data for chapter 10
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-show-data}    
```{r}
#| label: show-data

tbl10 <- base::readRDS("data/chap10/tbl10.rds")

skimr::skim(tbl10)
```

Skim raw data for chapter 10
:::

***



I have used the {**skimr**} package instead of {**tableone**}. It wouldn't be necessary to plot a histogram for `age` to decide if the mean or median has to be used. The tiny histogram at the right side of the `age` line already shows that age is not normally distributed. But for the sake of practice I will create the histogram in the next tab.

::::
:::::

###### age

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-age-hist}
: Show age distribution
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-age-dist}
```{r}
#| label: age-dist

my_hist_dnorm(tbl10, tbl10$age)

```

The distribution of age in the 2016 Pew Research Center library use data set
:::

::::
:::::

###### {tableone}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-desc-stats}
: Table of descriptive statistics
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-desc-stats}
```{r}
#| label: desc-stats
#| cache: true

tab_desc <- tableone::CreateTableOne(
    data = tbl10,
    strata = 'uses.lib',
    vars = c("age", "sex", "parent", "disabled",
             "ses", "raceth", "educ", "rurality"))

print(tab_desc,
      nonnormal = 'age',
      showAllLevels = TRUE)
```

Descriptive statistics with bivariate tests using {**tableone**}
:::
***

:::::{.my-remark}
:::{.my-remark-header}
:::::: {#rem-chap10-test-all-variables-together}
: Printing bivariate tests for all variables --- a `r glossary("QRP")`
::::::
:::
::::{.my-remark-container}
I am not feeling comfortable to use {**tableone**} to print descriptive statistics with bivariate test for all variables. Besides the mentioned danger of a `r glossary("QRP", "questionable research practice")` (QRP) in looking for statistically significance I would like to inspect the relationships more slowly and to see more details. I think at a minimum one should examine plots of the bivariate correlations. 

I have the same skepticism about the advice to "examine the frequencies and percentages in the table to identify some possible categories that may be driving the significant results for the bivariate tests". I think one should be guided to inspect more in detail in the first instance by theoretical assumptions, an approach that is fairly well demonstrated with Bayesian model design in "Statistical Rethinking" [@mcelreath2020]. 

To facilitate `r glossary("ExDA", "exploratory data analysis")` one could use packages that combine the analysis of different variables in one go, as my experiments with `GGally::ggpairs()` in @lst-chap09-plot-ggpairs or with `ggfortify::autoplot()` in @lst-chap09-test-ggfortify have shown. But this approach gets too overwhelming when there are more than 5-6 variables as I will demonstrate in @lst-chap10-bivariate-data with {**GGally**).


::::
:::::





::::
:::::

###### {GGally}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-bivariate-eda}
: Bivariate exploratory data analysis for variables of chapter 10
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-bivariate-data}

```{r}
#| label: plot-ggpairs
#| fig-height: 10
#| fig-width: 10
#| cache: true
#| warning: false

tbl10 |> 
    GGally::ggpairs()
```

Bivariate exploratory data analysis for variables of chapter 10
:::

*** 

There are too many plots (variables) in this example. I could divide easily the amount of variables into different patches as demonstrated in [Columns and Mapping](https://ggobi.github.io/ggally/articles/ggpairs.html#columns-and-mapping) and inspect these results in more details. But in order to get all variations I have to plan the approach systematically which destroys the advantage of automatic plotting.

::::
:::::



:::

::::
:::::


## Achievement 2: Understanding binary logistic regression {#sec-chap10-achievement2}

Binary logistic regression follows a similar format and process as linear regression (@sec-chap09), but the outcome or dependent variable is binary. Because the outcome is binary, or categorical consisting of two categories, the model predicts the probability that a person is in one of the two categories. In this chapter we want to predict the library use `uses.lib`.

Because of the binary outcome the linear regression model would not work since it requires a continuous outcome. However, the `r glossary("linear regression")` statistical model can be transformed using `r glossary("logit transformations")` in order to be useful for modeling binary outcomes.

### Formula of the logistic model

:::::{.my-theorem}
:::{.my-theorem-header}
:::::: {#thm-chap10-logistic-model}
: Formula for the statistical form of the logistic model
::::::
:::
::::{.my-theorem-container}
$$
\begin{align*}
p(y) = \frac{1}{1+e^{-(b_{0}+b_{1}x_{1}+b_{2}x_{2})}}
\end{align*}
$$ {#eq-chap10-logistic-model}

***

- $y$: binary outcome variable (e.g., library use) 
- $p(y)$: probability of the outcome (e.g., probability of library use) 
- $b_{0}$: y-intercept 
- $x_{1}$ and $x_{2}$: predictors of the outcome (e.g., age, rurality) 
- $b_{1}$ and $b_{2}$: coefficients for $x_{1}$ and $x_{2}$

::::
:::::

### Logistic function

The logistic function has a `r glossary("sigmoid")` shape that stretches from $–∞$ to $∞$ on the x-axis and from $0$ to $1$ on the y-axis. The function can take any value along the x-axis and give the corresponding value between $0$ and $1$ on the y-axis.

:::::{.my-theorem}
:::{.my-theorem-header}
:::::: {#thm-chap10-logistic-function}
: Formula of the logistic function
::::::
:::
::::{.my-theorem-container}
$$
\begin{align*}
\sigma(t) &= \frac{e^t}{1+e^t} =\\
&= \frac{1}{1 + e^{-t}}
\end{align*}
$$ {#eq-chap10-logistic-function}

***

$t$: value along the $x$-axis of the function
$\sigma$: value of $y$ for a specific value of $t$, or the probability of $y$ given $t$.

In the case of logistic regression, the value of $t$ will be the right-hand side of the regression model, which looks something like $β_{0} + β_{1}x$, where $x$ is an independent variable, $β_{1}$ is the coefficient (rather than slope) for that variable, and $β_{0}$ is the constant (rather than $y$-intercept).

Substituting this regression model for $t$ in the logistic function:

$$
\begin{align*}
p(y) = \frac{1}{1 + e^{-(β_{0} + β_{1}x)}}
\end{align*}
$$ {#eq-chap10-logistic-function}

::::
:::::

:::::{.my-example}
:::{.my-example-header}
:::::: {#exm-chap10-logistic-function}
: Drawing shape of logistic function empty and with example data points
::::::
:::
::::{.my-example-container}

::: {.panel-tabset}

###### Shape

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-logistic-function-shape}
: Shape of the logistic function
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-logistic-function-shape}
```{r}
#| label: logistic-function-shape

ggplot2::ggplot(data = data.frame(x = c(-5, 5)), 
         ggplot2::aes(x)) +
    ggplot2::stat_function(fun = 
           function(x) base::exp(x)/(1 + base::exp(x)), n = 100,
           linewidth = 1,
           ggplot2::aes(color = "Logistic function")
           ) +
    ggplot2::scale_x_continuous(
        labels = seq.int(10, 35, length.out = 5)
        ) +
    ggplot2::scale_color_manual(
        name = "",
        values = "hotpink2"
    ) +
    ggplot2::labs(
        x = "Values of input",
        y = "Value of outcome"
    )
```
Shape of the logistic function
:::

::::
:::::



###### Example with data points

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-logistic-function-data}
: Example of logistic function with data points
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-logistic-function-data}    
```{r}
#| label: logistic-function-data

## generate fake data frame
x1 = c(10.2, 13.0, 14.1, 14.3, 14.5, 14.7, 15.0, 15.5, 
      16.1, 17.3, 19.0, 19.2, 19.8, 21.0, 26.5)
y1 = rep(0, 15)
x2 = c(17.8, 18.2, 19.0, 21.4, 21.5, 22.7, 24.0, 27.2, 31.0, 32.4, 33.8)
y2 = rep(1, 11)
tbl <-  tibble::tibble(x = c(x1, x2),
                     y = c(y1, y2)) |> 
    dplyr::arrange(x)

## draw logistic function with faked data points
ggplot2::ggplot( 
        data = tbl,
        ggplot2::aes(x = x, y = y,
                 color = "Logistic function")
    ) +
    ggplot2::stat_smooth(
        data = tbl,
        formula = y ~ x,
        method = "glm",
        se = FALSE,
        method.args = list(family = binomial)
    ) +
    ggplot2::geom_point(
        ggplot2::aes(alpha = "Observation"),
        color = "grey41"
    ) +
    ggplot2::labs(
        x = "Values of input",
        y = "Value of outcome"
    ) +
    ggplot2::scale_color_manual(
        name = "",
        values = "hotpink2"
    ) +
    ggplot2::scale_alpha_manual(
        name = "",
        values = 0.5
    )

    
    
```

Example of logistic function with data points
:::

***

::::
:::::

###### Probability of outcome

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-logistic-function-data-annotated}
: Example of logistic function showing probability of outcome for x = 20
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-logistic-function-data-annotated}    
```{r}
#| label: logistic-function-data-annotated

## generate fake data frame
x1 = c(10.2, 13.0, 14.1, 14.3, 14.5, 14.7, 15.0, 15.5, 
      16.1, 17.3, 19.0, 19.2, 19.8, 21.0, 26.5)
y1 = rep(0, 15)
x2 = c(17.8, 18.2, 19.0, 21.4, 21.5, 22.7, 24.0, 27.2, 31.0, 32.4, 33.8)
y2 = rep(1, 11)
tbl <-  tibble::tibble(x = c(x1, x2),
                     y = c(y1, y2)) |> 
    dplyr::arrange(x)

## draw logistic function with faked data points
ggplot2::ggplot( 
    data = tbl,
    ggplot2::aes(x = x, y = y,
                 color = "Logistic function")
    ) +
    ggplot2::stat_smooth(
        data = tbl,
        formula = y ~ x,
        method = "glm",
        se = FALSE,
        method.args = list(family = binomial),
        ggplot2::aes(linetype = "predictor = 20 and\noutcome = .44 example")
    ) +
    ggplot2::geom_point(
        ggplot2::aes(alpha = "Observation"),
        color = "grey41"
        ) +
    ggplot2::geom_segment(
        x = 20, xend = 20,
        y = 0, yend = .44,
        color = "#1f6fca",
        linetype = "dashed"
    ) +
    ggplot2::geom_segment(
        x = 10, xend = 20,
        y = .44, yend = .44,
        color = "#1f6fca",
        linetype = "dashed"
    ) +
    ggplot2::labs(
        x = "Values of input",
        y = "Value of outcome"
    ) +
    ggplot2::scale_color_manual(
        name = "",
        values = "hotpink2"
    ) +
    ggplot2::scale_alpha_manual(
        name = "",
        values = 0.5
    ) +
    ggplot2::scale_linetype_manual(
        name = "",
        values = c("dashed", "dashed")
    ) +
    ggplot2::annotate("text", x = 10, y = .48, label = "0.44", color = "#1f6fca" ) +
    ggplot2::annotate("text", x = 20.5, y = -.02, label = "20", color = "#1f6fca" )
    
```

Example of logistic function showing a probability of outcome for $x = 20$
:::

***

Let's assume that the above graphic is a model for predicting library use from age. Then we can interpret it as a 44% probability of library use for a 20-year-old. Since 44% is lower than a 50% probability of the value of $y$, the model is predicting that the 20-year-old does not have the outcome. So, if the outcome is library use, the logistic model would predict this 20-year-old was not a library user. 


::::
:::::

:::





::::
:::::

:::::{.my-theorem}
:::{.my-theorem-header}
:::::: {#thm-chap10-odds}
: Formula of odds related to probability
::::::
:::
::::{.my-theorem-container}
$$
\begin{align*}
odds = \frac{probability}{1-probability}
\end{align*}
$$ {#eq-chap10-odds}

Substituting the logistic model from @eq-chap10-logistic-model:

$$
\begin{align*}
odds &= \frac{\frac{1}{1+e^{-(\beta_{0}+\beta_{1}x)}}}{1- \frac{1}{1+e^{-(\beta_{0}+\beta_{1}x)}}} = 
e^{\beta_{0} + \beta_{1}x}
\end{align*}
$$ {#eq-chap10-odds-logistic-model}

To be equivalent to the interpretation of the coefficients in linear regression, however, there is one more step. That is, what is the increase or decrease in the odds of the outcome with a one-unit increase in $x$?


$$
\begin{align*}
OR = \frac{e^{b_0+b_{1}(x+1)}}{e^{b_0+b_{1}x}}
\end{align*}
$$ {#eq-chap10-odds-ratio}

::::
:::::

@eq-chap10-odds-ratio shows that for every one-unit increase in the independent variable $x$, the odds of the outcome increase or decrease by $e^{b_1}$. Taking $e$ to the power of $b_1$ is referred to as exponentiating $b_1.$ After a model is estimated, the analyst will usually exponentiate the b value(s) in order to report odds ratios describing the relationships between each predictor and the outcome.

## Achievement 3: Interpreting a simple logistic regression {#sec-chap10-achievement3}

### NHST

#### NHST Step 1

Write the null and alternate hypotheses:

::: {.callout-note}
- **H0**: The model is no better than the baseline at predicting library use.
- **HA**: The model is better than the baseline at predicting library use.
:::

#### NHST Step 2

Compute the test statistic. 

The generalized linear model (`r glossary("GLM")`) or `stats::glm()` function can be used to estimate a binary logistic regression model. The model is generalized because it starts with the basic linear model and generalizes to other situations.

The `stats::glm()` function will treat the first category as the reference group (the group *without* the outcome) and the second category as the group *with* the outcome. To see the order of `uses.lib`, use `base::levels()` to show the levels in order and use `stats:relevel()` to re-order levels.

:::::{.my-example}
:::{.my-example-header}
:::::: {#exm-ID-text}
: Numbered Example Title
::::::
:::
::::{.my-example-container}

::: {.panel-tabset}

###### Reorder `uses.lib`

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-uses-lib-order}
: Reverse the order of `uses.lib`
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-uses-lib-order}
```{r}
#| label: uses-lib-order
#| results: hold

glue::glue("Order of uses.lib levels originally")
base::levels(tbl10$uses.lib)

tbl10.1 <- tbl10 |> 
    dplyr::mutate(uses.lib =
        forcats::fct_rev(uses.lib)
    )

save_data_file("chap10", tbl10.1, "tbl10.1.rds")


glue::glue("")
glue::glue("---------------------------------------")
glue::glue("Order of uses.lib levels reversed")
base::levels(tbl10.1$uses.lib)

```

Reversing order of `uses.lib`
:::

::::
:::::

In contrast to the book the order of my levels for the `uses.lib` data is reversed. It makes more sense to ask about if one uses the library, e.g., "yes" has to be the second category. To get the same order as in the book, I had to reverse the order. Instead of using `stats:relevel()` I reversed the order with `forcats::fct_rev()`.




###### lm10.1

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-lm10.1}
: Estimate library use model and print results
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-lm10.1}    
```{r}
#| label: lm10.1

lm10.1 <- 
    stats::glm(
        formula = uses.lib ~ age, 
        data = tbl10.1, 
        family = binomial(link = "logit")) 

save_data_file("chap10", lm10.1, "lm10.1.rds")

base::summary(lm10.1)
```

Estimate the simple library use model and print (= summmarize) the results
:::

***

@lst-chap10-lm10.1 uses `stats::family = binomial(link = "logit")`to specify the outcome variable. The "family" argument provides a description of the error distribution and link function to be used in the model. This is a convenient way to specify the details of the models and to distinguish between different types of generalized linear models that are appropriate for different kinds of outcome variables. In addition to the `glm()` help page you get additional information if you type [?family](https://rdrr.io/r/stats/family.html) into the console.

::::
:::::

###### Odds Ratio

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-compute-odds-ratio}
: Get model fit, model significance, and odds ratios
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-compute-odds-ratio}
```{r}
#| label: compute-odds-ratio

odds.n.ends::odds.n.ends(lm10.1)
```

Model fit, model significance, and odds ratios
:::

::::
:::::


:::

::::
:::::

***

#### NHST Step 3

Review and interpret the test statistics: 
Calculate the probability that your test statistic is at least as big as it is if there is no relationship (i.e., the null is true).

:::::{.my-example}
:::{.my-example-header}
:::::: {#exm-chap10-chi-squared-dist}
: Chi-squared distribution with df = 1
::::::
:::
::::{.my-example-container}

::: {.panel-tabset}

###### Theory: df = 1

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-chi-squared-graph}
: Theoretical chi-squared distribution with df = 1 
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-chi-squared-graph}
```{r}
#| label: chi-squared-graph-theory

ggplot2::ggplot() +
    ggplot2::xlim(0, 12) +
    ggplot2::stat_function(
        fun = dchisq,
        args = list(df = 1),
        linewidth = 1,
        color = "hotpink2"
    ) +
    ggplot2::labs(
        x = "Chi-squared statistic",
        y = "Probability density"
    )
```

Theoretical chi-squared distribution with df = 1 
:::

Graphing the probability of the chi-squared distribution with 1 degree of freedom to show that the probability that the chi-squared would be 10.815 or higher --- if the null hypothesis were true --- is the very small area under the curve from 10.815 to the right.

To get a better look at the position $x = 10.815$ let's zoom into the critical region. See @lst-chap10-chi-squared-graph-zoomed.

::::
:::::


###### Theory: df = 1, zoomed

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-chi-squared-graph-zoomed}
: Theoretical chi-squared distribution with df = 1, zoomed into the critical region of  p = 10.815
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-chi-squared-graph-zoomed}
```{r}
#| label: chi-squared-graph-zoomed

## Define start of shade
x_shade = 10.815 
df = 1
y_shade = stats::dchisq(x_shade, df)



## Define sequence of x-values
tib <- tibble::tibble(x = seq(9, 20, length.out = 300)) |> 
    # Compute density values
    dplyr::mutate(
        y = stats::dchisq(x, df)
    )

## Subset data for shaded area
shaded_area <- tib |> 
    dplyr::filter(x >= x_shade) |> 
    ## Necessary as starting point for y = 0!
    tibble::add_row(x = x_shade, y = 0, .before = 1)


tib |> 
    ## Plot the Chi-square distribution: df = 1
    ggplot2::ggplot(ggplot2::aes(x = x, y = y)) +
    ggplot2::geom_line(
        linewidth = 1,
        color = "hotpink2"
    ) +
    
    ## Draw segment 
    ggplot2::geom_segment(
        x = x_shade,
        y = 0,
        xend = x_shade,
        yend = y_shade
    ) +
    
    ## Shade curve
    ggplot2::geom_polygon(
        data = shaded_area, 
        fill = "lightblue",
        ggplot2::aes(x = x, y = y)
        ) +
    ggplot2::labs(
        x = "Chi-squared statistic",
        y = "Probability density" 
    ) + 
    ggplot2::annotate(
        geom = "text",
        x = 11.5,
        y = .00058,
        label = base::round(stats::dchisq(x_shade, df), 6)
    )


```

Theoretical chi-squared distribution with df = 1, zoomed into the critical region 
:::

Here we see that at the chi-square statistic of 10.815 the p-value is with .0005 very tiny and about 100 times much smaller as the level of statistical significance of .05. 

::::
:::::

When I developed above plots I wondered why in the book the graph is a rough line and the sample size (without NA's) of $n = 1501$ was mentioned. I learned that my curve was the theoretical curve whereas I need the randomized values to get a more rough simulation that is nearer the factual data.


###### Randomized

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chi-squared-graph-randomized}
: Randomized chi-squared distribution with df = 1, n = 1571
::::::
:::
::::{.my-r-code-container}
::: {#lst-chi-squared-graph-randomized}    
```{r}
#| label: chi-squared-graph-randomized

set.seed(42)
n = 1571
df = 1

chisq_dist <- tibble::tibble(x = stats::rchisq(n, df))

chisq_dist |> 
    ggplot2::ggplot(
        ggplot2::aes(x)
    ) +
    ggplot2::geom_density(
        linewidth = 1,
        color = "hotpink2"
    ) +
    ggplot2::labs(
        x = "Chi-squared statistic",
        y = "Probability density"
    )
```

Randomized chi-squared distribution with df = 1, n = 1571
:::



This is a randomized chi-squared distribution. I could not shade values $p > 10.815$ because there were only three rows with values greater than that. 



::::
:::::

:::::: {#tdo-chap10-empiricial-chisq-dist}
:::::{.my-checklist}
:::{.my-checklist-header}
TODO: I wonder if I could provide an empirical chi-squared distribution with the actual data.
:::

:::::
How to plot an empirical chi-squared distribution with real data?
:::

:::


::::
:::::

:::::{.my-resource}
:::{.my-resource-header}
:::::: {#lem-chap10-chisq-video}
: Video about the chi-squared distribution
::::::
:::
::::{.my-resource-container}
I found a lengthy video tutorial (19:31) using RStudio featuring chi-squared distribution. You will see, `r glossary("pdf")`, `r glossary("cumulative distribution function", "cdf")`, `r glossary("quantile")`, plotting, examples, independence, `r glossary("Goodness-of-fit", "goodness of fit")` and explanations. There is also a accompanying web page with text and the code.
::::
:::::



#### NHST Step 4

Conclude and write report.

::: {.callout #rep-chap10-chisq-lm10.1}
The chi-squared test statistic for a logistic regression model with age predicting library use had a p-value of .001. This p-value indicates there is a .1% chance of a chi-squared statistic this large or larger if the null hypothesis were true. The null hypothesis is therefore rejected in favor of the alternate hypothesis that the model is better than the baseline at predicting library use. A logistic regression model including age was statistically significantly better than a null model at predicting library use [$χ^2(1) = 10.82; p = .001$].
:::

### Interpreting odds ratio significance

Both, `base::summary()` and `odds.n.ends::odds.n.ends()` included values and significance statistics for the age predictor. The `odds.n.ends()` output included `r glossary("odds ratio", "odds ratios")`, which are easier to interpret. The outcome is transformed by the logistic function, therefore the coefficients from `summary()` are not easy to interpret directly.

Looking at @lst-chap10-compute-odds-ratio we see that `age`has a odds ratio of .99. This could be interpreted as, “The odds of library use decrease by 1% for every 1-year increase in age.” The 1% comes from subtracting the odds ratio of .99 from 1 and multiplying by 100 to convert it to a percent. This is a stategy to make interpreting odds below 1 easier. Otherwise we would have to say: “The odds of library use are .99 times as high with every 1-year increase in age.”

**When the confidence interval includes 1, the odds of the outcome are not statistically significantly different with a change in the independent variable.**

The odds ratio for the age variable is less than 1, and the confidence interval does not include 1. Thus, the interpretation of this odds ratio would be as follows: 

::: {.callout #rep-chap10-odds-ratio}
##### Interpretation of age odds ratio

The odds of library use are 1% lower for every 1-year increase in age ($OR = .99; 95% CI: .986–.996$).
:::


#### NHST Step 1

Write the null and alternate hypotheses:

::: {.callout-note}
- **H0**: Library use is not associated with age.
- **HA**: Library use is associated with age.
:::

#### NHST Step 2

Compute the test statistic. 

The `base::summary()` function following a `stats::glm()` function includes a `r glossary("z-score", "z-statistic")` comparing the coefficient estimate to zero. The z-score is a measure how many standard deviations away a value is from a mean. But for logistic regression, the coefficient divided by the `r glossary("standard error")` --- not by the `r glossary("standard deviation")` --- follows a z-distribution. This z-statistic is the test statistic for the `r glossary("Wald", "Wald test")`, which has the same purpose (but follows a different distribution) as the Wald test from @sec-chap09-achievement4.

In the case of the `age` variable, dividing the estimate of $-0.008838$ by its standard error of $0.002697$ gives a z-statistic of $-3.276974$, which is well beyond the boundary of $–1.96$ for statistical significance when $\alpha$ is set at $.05$.

The z-distribution is a normal distribution with a mean of 0 and a standard deviation of 1.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-chap10-z-dist-odds-ratio}
: z-distribution for sample size of 1571
::::::
:::
::::{.my-r-code-container}
::: {#lst-chap10-z-dist-odds-ratio}
```{r}
#| label: z-dist-odds-ratio

nhstplot::plotztest(
    z = -3.28,
    tails = "one",
    xmax = 5
    )

```

z-distribution for sample size of 1571
:::

::::
:::::


#### NHST Step 3

Review and interpret the test statistics: 
Calculate the probability that your test statistic is at least as big as it is if there is no relationship (i.e., the null is true).

The area under the curve to the left of the test statistic in @lst-chap10-z-dist-odds-ratio is very small. Given this area is very small, the p-value of .00105 in the output @lst-chap10-lm10.1 from `base::summary(lm10.1)` makes sense. There is a .105% probability that this sample came from a population where there was no relationship between age and library use. Thus, there is a statistically significant relationship between age and library use (z = –3.28; p = .001).


#### NHST Step 4

Conclude and write report.

The odds ratio for age is .99 with a 95% CI of .986–.996. The confidence interval shows the range where the odds ratio likely is in the population. Because the confidence interval does not include 1, this indicates that the odds ratio is statistically significantly different from 1. The interpretation would be as follows:

::: {.callout #rep-odds-ratio-significance}
##### Interpreting odds ratio significance

 The null hypothesis of no relationship between library use and age is rejected. The odds of library use are 1% lower for every 1-year increase in age in the sample (OR = .99; 95% CI: .986–.996). The 95% confidence interval indicates that the odds of library use are .4%–1.4% lower with each 1-year increase in age in the population that the sample came from.
:::

## Achievement 4: Interpreting two measures of model fit {#sec-chap10-achievement4}

For linear regression, the $R^2$ statistic measured how well the model fit the observed data by measuring how much of the variability in the outcome was explained by the model. The concept of variance is appropriate for continuous but not categorical variables. There are several measures for categorical model fit, including the percent correctly predicted, sometimes called `r glossary("count-R-squared", "count $R^2$")` and the `r glossary("Adjusted-count-R2", "adjusted count $R^2$")`, which adjusts the count $R^2$ for the number of people in the largest of the two categories of the outcome.

### Percent correctly predicted

The percent correctly predicted by the model is computed using the predicted probabilities, or fitted values, for each of the observations and comparing these probabilities to the true value of the outcome.

:::::{.my-theorem}
:::{.my-theorem-header}
:::::: {#thm-chap10-percent-correctly-predicted}
: Percent correctly predicted or count $R^2$
::::::
:::
::::{.my-theorem-container}
$$
\begin{align*}
R^2_{count} = \frac{n_{correct}}{n_{total}}
\end{align*}
$$ {#eq-chap10-percent-correctly-predicted}
::::
:::::

For example, if a person in the data set were predicted to have a chance of more than 50% of library use, this would be transformed into a “yes” or “1” value of the outcome and then compared to the person’s actual library use. If the predicted value and the true value matched, this would be considered a correct prediction. The same vice-versa for predicted values less than 50%. The total number of people the model gets correct out of the total number of people in the data analyzed is the `r glossary("count-R-squared", "percent correctly predicted")` or count $R^2$.

The @lst-chap10-compute-odds-ratio includes a table showing how many observations were correctly predicted in each category of the outcome.

:::::{.my-theorem}
:::{.my-theorem-header}
:::::: {#thm-chap10-percent-correctly-predicted-example}
: Calculate the percent correctly predicted with the `lm10.1` data
::::::
:::
::::{.my-theorem-container}
$$
\begin{align*}
R^2_{count} = \frac{338 + 500}{1571} = \frac{838}{1571} = 0.5334
\end{align*}
$$ {#eq-chapXY-formula}
::::
:::::

### Adjusted count $R^2$

An alternative measure of percent correctly predicted is the `r glossary("Adjusted-count-R2", "adjusted count R^2")` measure. It adjusts the count $R^2$ for the number of people in the largest of the two categories of the outcome.

:::::{.my-theorem}
:::{.my-theorem-header}
:::::: {#thm-chap10-adjusted-count-r-squared}
: Adjusted count $R^2$
::::::
:::
::::{.my-theorem-container}
$$
\begin{align*}
R^2_{count.adj} = \frac{n_{correct}- n_{most.common.outcome}}{n_{total}- n_{most.common.outcome}}
\end{align*}
$$ {#eq-chap10-adjusted-count-r-squared}
::::
:::::

The argument behind this adjustment is that a null model, or a model with no predictors, could get a good percent correctly predicted just by predicting everyone was in the outcome category that had the bigger percentage of people in it.

For the library use data, the most common category is library nonuse (or 0), with 798 of the 1571 participants with complete data for the model. Without knowing anything about library use, you could predict everyone in the data set was a nonuser and be right $\frac{788}{1571}$ or 50.8% of the time. Using the age predictor, the model is right $\frac{338+500}{1571}$ or 53% of the time. While this is not a huge increase, it did classify 40 additional people correctly compared to using the percentages in the outcome categories with no other information.

The model using age to predict library use was correct 53% of the time (Count $R^2$ = .53). The adjusted count $R^2$ would be $\frac{338+500-798}{1571-798}$ or .05.

::: {.callout #rep-chap10-adjusted-r-squared}
##### Interpretation of adjusted $R^2$ in `lm10.1`

There were 5% more correct predictions by the age model than by the baseline (Adjusted Count $R^2$ = .05).
:::

### Pseudo-$R^2$

Pseudo-$R^2$ is another measure that are reported relatively frequently. This measure generally tries to quantify the reduction in lack of fit between a null and full model. You can compute Pseudo-$R^2$  

:::{.my-bulletbox}
:::: {.my-bulletbox-header}
::::: {.my-bulletbox-icon}
:::::
:::::: {#bul-chap10-pseudo-r2-functions}
::::::
: Packages with function for computing pseudo-$R^2$
::::
:::: {.my-bulletbox-body}
- with r2_mcfadden() from the {**performance**} package (see: @pak-performance)
- with `PseudoR2()` from the {**DescTools**} package (see: @pak-DescTools),
- with `lrm()`(instead of the `stats::glm()`!) from the {**rms**} package (see: @pak-rms)
- with `pR2()`from the {**pscl**} package (see: @pak-pscl), and
- with `pseudo_r2() from the {**pubh**} package (see: @pak-pubh).

Many of these packages have also function for percent correctly predicted and the adjusted count $R^2$ measure.
::::
:::


::: {.callout-caution #cau-chap10-pseudo-r2}
##### Interpreting pseudo-$R^2$

I haven't tried out yet the functions of @bul-chap10-pseudo-r2-functions. Besides I am not certain how to calculate and interpret the pseudo-$R^2$ measure. I have seen that there is diversity in the approaches and I need a better understanding of the theoretical background.
:::


### Sensitivity and specificity

Sometimes it is useful to know whether the model is better at predicting people with the outcome or people without the outcome. The measures used for these two concepts are sensitivity and specificity.

`r glossary("Sensitivity")` determines the percentage of the 1s or “yes” values the model got correct, while `r glossary("specificity")` computes the percentage of 0s or “no” values the model got correct.

In @lst-chap10-compute-odds-ratio, the sensitivity is 43.7% while the specificity is 62.7%. The model was better at predicting the "no" values than the "yes" values. These percentages could also be computed from the frequency table in the output: The model predicted 500 of the 798 people in the 0 category correctly (62.7%) and 338 of the 773 in the 1 category correctly (43.7%).

## Achievement 5: Estimating a larger logistic regression model {#sec-chap10-achievement5}

## Exercises (empty)

## Glossary

```{r}
#| label: glossary-table
#| echo: false

glossary_table()
```

------------------------------------------------------------------------

## Session Info {.unnumbered}

::: my-r-code
::: my-r-code-header
Session Info
:::

::: my-r-code-container
```{r}
#| label: session-info

sessioninfo::session_info()
```
:::
:::
